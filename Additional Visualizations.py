# -*- coding: utf-8 -*-
"""Copy of Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-5FCnGUCDLmUvN838bvQ1UZ0rOvU3ORr
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import files

fillings = files.upload()
# Ensure file_path3 is a string with the file name/path
file_path ='lastnalastna (1).xlsx'    # Update with your file path if needed

# Read the data into a DataFrame
df = pd.read_excel(file_path)

# Display the first few rows of the DataFrame
print(df.head())

# Get numerical columns for box plots
numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns

# Set the style of seaborn
sns.set(style="whitegrid")

# Create a box plot for each numerical column with a Set2 palette
for column in numerical_columns:
    plt.figure(figsize=(10, 6))
    sns.boxplot(data=df, y=column, palette='Set2')
    plt.title(f'Box Plot of {column}')
    plt.ylabel(column)
    plt.show()

sheet_name1 = '0'  # Replace with your sheet name if necessary

# Read the data into a DataFrame
df = pd.read_excel(file_path, sheet_name=sheet_name1)

# Display the first few rows of the DataFrame
print(df.head())

# Create box plots for each numerical column
# Assuming the DataFrame has numerical columns for box plots
numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns

# Set the style of seaborn
sns.set(style="whitegrid")

# Create a box plot for each numerical column
for column in numerical_columns:
    plt.figure(figsize=(10, 6))
    sns.boxplot(data=df, y=column, palette='Set2')
    plt.title(f'Box Plot of {column}')
    plt.ylabel(column)
    plt.show()

# Load the Excel file
file_path = 'lastnalastna (1).xlsx'  # Replace with your file path
sheet_name = '1'  # Replace with your sheet name if necessary

# Read the data into a DataFrame
df = pd.read_excel(file_path, sheet_name=sheet_name)

# Display the first few rows of the DataFrame
print(df.head())

# Create violin plots for each numerical column
# Assuming the DataFrame has numerical columns for violin plots
numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns

# Set the style of seaborn
sns.set(style="whitegrid")

# Create a violin plot for each numerical column
for column in numerical_columns:
    plt.figure(figsize=(10, 6))
    sns.violinplot(y=df[column], palette='Set2')
    plt.title(f'Violin Plot of {column}')
    plt.ylabel(column)
    plt.show()

sheet_name = '0'  # Replace with your sheet name if necessary

# Read the data into a DataFrame
df = pd.read_excel(file_path, sheet_name=sheet_name)

# Display the first few rows of the DataFrame
print(df.head())

# Create violin plots for each numerical column
# Assuming the DataFrame has numerical columns for violin plots
numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns

# Set the style of seaborn
sns.set(style="whitegrid")

# Create a violin plot for each numerical column
for column in numerical_columns:
    plt.figure(figsize=(10, 6))
    sns.violinplot(y=df[column], palette='Set2')
    plt.title(f'Violin Plot of {column}')
    plt.ylabel(column)
    plt.show()

# Load the dataset from the uploaded file
file_path = "lastnalastna (1).xlsx"

# Read the data from the Excel file:
# Sheet 1 corresponds to status 1 and sheet 0 corresponds to status 0.
status_1_df = pd.read_excel(file_path, sheet_name='1')
status_0_df = pd.read_excel(file_path, sheet_name='0')

# Drop columns that contain "Code_Number_6digits" (if any) in both DataFrames
status_1_df = status_1_df.drop(columns=[col for col in status_1_df.columns if "Code_Number_6digits" in col], errors='ignore')
status_0_df = status_0_df.drop(columns=[col for col in status_0_df.columns if "Code_Number_6digits" in col], errors='ignore')

# If the 'Status' column is not present, add it manually:
status_1_df["Status"] = 1
status_0_df["Status"] = 0

# Ensure the 'Status' column is numeric
status_1_df['Status'] = pd.to_numeric(status_1_df['Status'], errors='coerce')
status_0_df['Status'] = pd.to_numeric(status_0_df['Status'], errors='coerce')

# Drop rows with NaN in 'Status' if any exist after conversion
status_1_df = status_1_df.dropna(subset=['Status'])
status_0_df = status_0_df.dropna(subset=['Status'])

# Remove non-feature columns from interleaving; in this case we exclude 'Status'
features_status1 = status_1_df.drop(columns=['Status'])
features_status0 = status_0_df.drop(columns=['Status'])

# Create a list of interleaved column names
interleaved_columns = []
for col in features_status1.columns:
    interleaved_columns.append(f"{col}_status_1")  # Add status 1 version
    if col in features_status0.columns:
        interleaved_columns.append(f"{col}_status_0")  # Add status 0 version

# Rename columns in each DataFrame to reflect the status
features_status1 = features_status1.rename(columns={col: f"{col}_status_1" for col in features_status1.columns})
features_status0 = features_status0.rename(columns={col: f"{col}_status_0" for col in features_status0.columns})

# Combine the features by concatenating the DataFrames along columns
combined_data = pd.concat([features_status1, features_status0], axis=1)

# Rearrange columns in the interleaved order
combined_data = combined_data[interleaved_columns]

# Save the interleaved data to an Excel file
output_combined_file = "combined_all_features_interleaved.xlsx"
combined_data.to_excel(output_combined_file, index=False)

# Provide download link
output_combined_file

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import re

# Define file path for the uploaded dataset
file_path = "lastnalastna (1).xlsx"

# Load the dataset from the Excel file
status_1_df = pd.read_excel(file_path, sheet_name='1')
status_0_df = pd.read_excel(file_path, sheet_name='0')

# Add 'Status' column to each dataset
status_1_df["Status"] = 1
status_0_df["Status"] = 0

# Ensure 'Status' is numeric
status_1_df["Status"] = pd.to_numeric(status_1_df["Status"], errors="coerce")
status_0_df["Status"] = pd.to_numeric(status_0_df["Status"], errors="coerce")

# Drop rows with NaN in 'Status' if any exist
status_1_df = status_1_df.dropna(subset=["Status"])
status_0_df = status_0_df.dropna(subset=["Status"])

# Drop 'Status' column from features
features_status1 = status_1_df.drop(columns=["Status"])
features_status0 = status_0_df.drop(columns=["Status"])

# Create interleaved column names
interleaved_columns = []
for col in features_status1.columns:
    interleaved_columns.append(f"{col}_status_1")  # Add status 1 version
    if col in features_status0.columns:
        interleaved_columns.append(f"{col}_status_0")  # Add status 0 version

# Rename columns to reflect status
features_status1 = features_status1.rename(columns={col: f"{col}_status_1" for col in features_status1.columns})
features_status0 = features_status0.rename(columns={col: f"{col}_status_0" for col in features_status0.columns})

# Concatenate along columns
combined_data = pd.concat([features_status1, features_status0], axis=1)

# Rearrange columns in the interleaved order
combined_data = combined_data[interleaved_columns]

# Replace NaN with None for plotting consistency
data_cleaned = combined_data.replace({pd.NA: None, np.nan: None})

# Extract feature names by removing only the last "_status_#" part
feature_base_names = sorted(set(re.sub(r"_status_[01]$", "", col) for col in combined_data.columns))

# Identify valid features with both status 1 and status 0 columns
valid_features = [feat for feat in feature_base_names if f"{feat}_status_1" in combined_data and f"{feat}_status_0" in combined_data]

# Convert all columns to numeric, coercing errors to NaN
data_cleaned = data_cleaned.apply(pd.to_numeric, errors='coerce')

# Function to visualize one feature pair at a time for box plots
def visualize_interleaved_box_pairs_one_by_one(feature_list, data):
    for feat in feature_list:
        pair = (f"{feat}_status_1", f"{feat}_status_0")
        if pair[0] in data and pair[1] in data:
            subset_df = data[list(pair)].dropna()
            melted = subset_df.melt(var_name='Feature', value_name='Value')

            plt.figure(figsize=(8, 4))
            sns.boxplot(data=melted, x='Feature', y='Value', palette='Set2')
            plt.title(f"Box Plot for: {pair[0]} vs {pair[1]}")
            plt.ylabel("Values")
            plt.xticks(rotation=0)
            plt.show()

# Function to visualize one feature pair at a time for violin plots
def visualize_interleaved_violin_pairs_one_by_one(feature_list, data):
    for feat in feature_list:
        pair = (f"{feat}_status_1", f"{feat}_status_0")
        if pair[0] in data and pair[1] in data:
            subset_df = data[list(pair)].dropna()
            melted = subset_df.melt(var_name='Feature', value_name='Value')

            plt.figure(figsize=(8, 4))
            sns.violinplot(data=melted, x='Feature', y='Value', palette='Set2')
            plt.title(f"Violin Plot for: {pair[0]} vs {pair[1]}")
            plt.ylabel("Values")
            plt.xticks(rotation=0)
            plt.show()

# Display features one by one
visualize_interleaved_box_pairs_one_by_one(valid_features, data_cleaned)
visualize_interleaved_violin_pairs_one_by_one(valid_features, data_cleaned)

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Define file path for the uploaded dataset
file_path = "lastnalastna (1).xlsx"

# Load the dataset from the Excel file
status_1_df = pd.read_excel(file_path, sheet_name='1')
status_0_df = pd.read_excel(file_path, sheet_name='0')

# Drop unnecessary columns
status_1_df = status_1_df.drop(columns=[col for col in status_1_df.columns if "Code_Number_6digits" in col or "Filename" in col])
status_0_df = status_0_df.drop(columns=[col for col in status_0_df.columns if "Code_Number_6digits" in col or "Filename" in col])

# Add 'Status' column to each dataset
status_1_df["Status"] = 1
status_0_df["Status"] = 0

# Concatenate both classes into a single dataset
df = pd.concat([status_1_df, status_0_df], ignore_index=True)

# Separate features and target
features = df.drop(columns=["Status"])
target = df["Status"]

# Split the data into separate DataFrames for each class
df_class0 = df[df["Status"] == 0].drop(columns=["Status"])
df_class1 = df[df["Status"] == 1].drop(columns=["Status"])

# Compute the correlation matrix for each class
corr_class0 = df_class0.corr()
corr_class1 = df_class1.corr()

# Define a function to plot correlation matrices
def plot_correlation_matrix(corr_matrix, title):
    plt.figure(figsize=(20, 16))
    sns.heatmap(corr_matrix, annot=False, cmap="coolwarm")
    plt.title(title, fontsize=20)
    plt.tight_layout()
    plt.show()

# Plot the correlation matrix for Class 0
plot_correlation_matrix(corr_class0, "Correlation Matrix for Class 0 ")

# Plot the correlation matrix for Class 1
plot_correlation_matrix(corr_class1, "Correlation Matrix for Class 1 ")

# Compute the difference between the two correlation matrices
diff_corr = corr_class0 - corr_class1

# Plot the difference in correlations
plot_correlation_matrix(diff_corr, "Difference in Correlation (Class 0 - Class 1)")

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# File path to your Excel file
file_path = "lastnalastna (1).xlsx"

# Load the Excel file and read sheets "1" (Class 1) and "0" (Class 0)
xls = pd.ExcelFile(file_path)
df_class1 = pd.read_excel(xls, sheet_name="1")
df_class0 = pd.read_excel(xls, sheet_name="0")

# Set visual style
sns.set_style("whitegrid")

# Use Seaborn's "Set2" palette with 2 colors (palette 2)
palette2 = sns.color_palette("Set2", 2)

# Create figure with two subplots (side-by-side)
fig, ax = plt.subplots(1, 2, figsize=(10, 5), sharey=True)

# Plot Class 1 Gender Distribution
sns.countplot(
    x="Gender",
    data=df_class1,
    order=[1, 2],  # Ensure that 1 (Male) comes first, then 2 (Female)
    ax=ax[0],
    palette=palette2
)
ax[0].set_title("Class 1 Gender Distribution", fontsize=12, fontweight='bold')
ax[0].set_xlabel("Gender", fontsize=10)
ax[0].set_ylabel("Count", fontsize=10)
ax[0].set_xticklabels(["Male", "Female"])

# Plot Class 0 Gender Distribution
sns.countplot(
    x="Gender",
    data=df_class0,
    order=[1, 2],
    ax=ax[1],
    palette=palette2
)
ax[1].set_title("Class 0 Gender Distribution", fontsize=12, fontweight='bold')
ax[1].set_xlabel("Gender", fontsize=10)
ax[1].set_ylabel("Count", fontsize=10)
ax[1].set_xticklabels(["Male", "Female"])

# Adjust layout and display the plots
plt.tight_layout()
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# File path to your Excel file
file_path = "lastnalastna (1).xlsx"

# Load the Excel file and read sheets "1" (Status 1) and "0" (Status 0)
xls = pd.ExcelFile(file_path)
df_status1 = pd.read_excel(xls, sheet_name="1")
df_status0 = pd.read_excel(xls, sheet_name="0")

# Ensure that the 'Age' column is numeric (if necessary)
df_status1['Age'] = pd.to_numeric(df_status1['Age'], errors='coerce')
df_status0['Age'] = pd.to_numeric(df_status0['Age'], errors='coerce')

# Drop missing values in Age (if any)
df_status1 = df_status1.dropna(subset=['Age'])
df_status0 = df_status0.dropna(subset=['Age'])

# Get the unique integer ages (sorted) from both dataframes
ages = sorted(set(df_status0['Age'].astype(int).unique()).union(set(df_status1['Age'].astype(int).unique())))

# Compute counts for each age for each status
counts_status0 = [df_status0[df_status0['Age'].astype(int) == age].shape[0] for age in ages]
counts_status1 = [df_status1[df_status1['Age'].astype(int) == age].shape[0] for age in ages]

# Set visual style and palette
sns.set_style("whitegrid")
palette2 = sns.color_palette("Set2", 2)

# Create the grouped bar plot
plt.figure(figsize=(12, 6))
width = 0.4  # Width of each bar
x = np.array(ages)  # x positions (integers)

# Plot Status 0 on the left side of each tick and Status 1 on the right
plt.bar(x - width/2, counts_status0, width=width, color=palette2[0], label="Status 0")
plt.bar(x + width/2, counts_status1, width=width, color=palette2[1], label="Status 1")


plt.ylabel("Count", fontsize=12)
plt.title("Age Distribution by Status", fontsize=14, fontweight='bold')
plt.xticks(x, [str(age) for age in ages])  # Ensure x-axis ticks are integers with spacing
plt.legend()
plt.tight_layout()
plt.show()

